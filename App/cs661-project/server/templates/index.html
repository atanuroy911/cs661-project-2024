<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Network Graph</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f7f7f7;
        }

        svg {
            border: 1px solid #ddd;
            background-color: #fff;
        }

        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .nodes circle {
            stroke: #000;
            stroke-width: 1px;
            fill: #555;
            cursor: pointer;
        }

        .node-label {
            font-size: 12px;
            font-weight: bold;
        }

        .node-legend {
            cursor: pointer;
            padding: 2px;
            user-select: none;
            margin-top: 5px;
        }

        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            background: white;
        }

        /* Add custom styles for active tab */
        .active-tab {
            background-color: #4a90e2;
            /* Change to desired color */
            color: white;
        }
    </style>
</head>

<body>
    <div id="legend"></div>
    <div class="flex flex-col">
        <div id="data-selector" class="flex">
            <!-- Add Tailwind CSS classes for tabs -->
            <button onclick="loadGraphData(1)" class="tab-btn mx-2 bg-gray-200 text-gray-800 px-4 py-2">K = 1</button>
            <button onclick="loadGraphData(2)" class="tab-btn mx-2 bg-gray-200 text-gray-800 px-4 py-2">K = 3</button>
            <button onclick="loadGraphData(3)" class="tab-btn mx-2 bg-gray-200 text-gray-800 px-4 py-2">K = 5</button>
            <button onclick="loadGraphData(4)" class="tab-btn mx-2 bg-gray-200 text-gray-800 px-4 py-2">K = 7</button>
        </div>
        <svg></svg>
    </div>
    <script>
        const width = window.innerWidth * 0.8;
        const height = window.innerHeight * 0.8;

        const svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height);

        const legendDiv = d3.select("#legend");

        const names = [
            'Rabindra Nath Tagore', 'Raihan Sharif', 'Rajani Kanto Sen', 'Rajib Ahmed',
            'Rana Sheikh', 'Rifat Alom', 'Robiul Islam Jibon', 'Rongu Shahabuddin',
            'Ronjon', 'Roton Shaha', 'Rudro Mohammad Shohidullah', 'Rupchad Pokki',
            'Sahana', 'Sayem', 'Sayyed Shamsul Haque', 'Sejan Mahmud', 'Shafiq Tuhin',
            'Shah Abdul Karim', 'Shahan Kobondo', 'Shahinur Islam'
        ];

        function loadGraphData(graphNumber) {
            d3.json(`/graph_data/${graphNumber}`).then(function (graph) {

                svg.selectAll("*").remove();
                const nodes = graph.nodes;
                const links = graph.links;

                // Calculate the minimum possible threshold (mean weight)
                const edgeWeights = links.map(d => d.value);
                const minThreshold = d3.mean(edgeWeights);

                // Calculate quantiles for edge weight thresholds
                const quantiles = d3.quantileSorted(edgeWeights, [0.5, 0.8, 1]);
                const veryLightThreshold = quantiles[0];
                const lightThreshold = quantiles[1];
                const mediumThreshold = quantiles[2];

                // Filter out links with weights below the minimum threshold
                const filteredLinks = links.filter(d => d.value >= minThreshold);

                const linkElements = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(filteredLinks)
                    .enter()
                    .append("line");

                const nodeElements = svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("g")
                    .data(nodes)
                    .enter()
                    .append("g");

                const circles = nodeElements
                    .append("circle")
                    .attr("r", 10)
                    .call(d3.drag()
                        .on("start", dragStarted)
                        .on("drag", dragged)
                        .on("end", dragEnded));

                const labels = nodeElements
                    .append("text")
                    .attr("class", "node-label")
                    .attr("dx", 12)
                    .attr("dy", ".35em")
                    .text(d => names[d.id - 1]); // Adjust the index to match the zero-based index of the array


                const legendEntries = legendDiv.selectAll(".node-legend")
                    .data(nodes)
                    .enter()
                    .append("div")
                    .attr("class", "node-legend")
                    .text((d, i) => names[d.id - 1]) // Display artist names instead of "Node 1", "Node 2", etc.
                    .on("click", toggleNode);


                // Set initial visibility for all nodes and links
                nodeElements.style("opacity", 1);
                linkElements.style("opacity", 1);

                // Set edge appearances based on thresholds
                updateEdgeAppearances(minThreshold, veryLightThreshold, lightThreshold, mediumThreshold);

                function toggleNode(event, d) {
                    const isActive = !d3.select(this).classed("active");
                    d3.select(this).classed("active", isActive);

                    const nodeOpacity = isActive ? 1 : 0;
                    nodeElements.filter(n => n.id === d.id).style("opacity", nodeOpacity);

                    linkElements.style("opacity", function (l) {
                        const sourceVisible = isNodeVisible(l.source.id);
                        const targetVisible = isNodeVisible(l.target.id);
                        return (sourceVisible && targetVisible) ? 1 : 0;
                    });
                }

                function isNodeVisible(nodeId) {
                    const node = nodeElements.filter(n => n.id === nodeId);
                    return node.style("opacity") === "1";
                }

                function dragStarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragEnded(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }

                const simulation = d3.forceSimulation()
                    .force("link", d3.forceLink().id(d => d.id).distance(250))
                    .force("charge", d3.forceManyBody().strength(-200))
                    .force("center", d3.forceCenter(width / 2, height / 2));

                simulation
                    .nodes(nodes)
                    .on("tick", ticked);

                simulation.force("link")
                    .links(filteredLinks);

                function ticked() {
                    linkElements
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    nodeElements
                        .attr("transform", d => `translate(${d.x}, ${d.y})`);
                }

                function updateEdgeAppearances(minThreshold, veryLightThreshold, lightThreshold, mediumThreshold) {
                    linkElements
                        .style("stroke-width", function (d) {
                            const weight = d.value;
                            if (weight >= mediumThreshold) {
                                return 3; // Boldest stroke for edges above medium threshold
                            } else if (weight >= lightThreshold) {
                                return 2; // Lighter stroke for edges between light and medium thresholds
                            } else {
                                return 1; // Lightest stroke for edges between very light and light thresholds
                            }
                        })
                        .style("stroke-opacity", function (d) {
                            const weight = d.value;
                            if (weight >= mediumThreshold) {
                                return 1; // Fully opaque for edges above medium threshold
                            } else if (weight >= lightThreshold) {
                                return 0.7; // Semi-opaque for edges between light and medium thresholds
                            } else {
                                return 0.4; // More transparent for edges between very light and light thresholds
                            }
                        });
                }
            });
        }
        loadGraphData(1);
    </script>
</body>

</html>